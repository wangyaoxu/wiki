<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/colorful.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Go入门笔记 - wiki</title>
    <meta name="keywords" content="technology, machine learning, data mining, economics, accounting"/>
    <meta name="description" content="A wiki website of wangyaoxu when I learned new knowledgy and technics."/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  </head>

  <body>
    <div id="container" class="typo">
      
<div id="header">
  <div id="post-nav">
    <a href="/wiki/">wiki</a>
    &nbsp;&#187;&nbsp;
    <a href="/wiki/#go">go</a>
    &nbsp;&#187;&nbsp;Go入门笔记
    <span class="updated">当前页面最后更新&nbsp;
    2017-08-23 16:52
    
    </span>
  </div>
</div>
<div class="clearfix"></div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">教程</a></li>
<li><a href="#_2">笔记</a><ul>
<li><a href="#goroot-gopath">GOROOT 和 GOPATH</a></li>
<li><a href="#package-import">package 和 import</a></li>
<li><a href="#exported-names">Exported names</a></li>
<li><a href="#function">Function</a></li>
<li><a href="#variable-constants-and-type">Variable, Constants and Type</a></li>
<li><a href="#for-if-switch">for / if / switch</a></li>
<li><a href="#defer">defer</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#struct">Struct</a></li>
<li><a href="#array">Array</a></li>
<li><a href="#slice">Slice</a></li>
<li><a href="#maps">Maps</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#interfaces">Interfaces</a></li>
<li><a href="#goroutine">goroutine</a></li>
<li><a href="#channel">channel</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="_1">教程</h2>
<ul>
<li><a href="https://tour.golang.org/">A Tour of Go</a></li>
<li><a href="https://gobyexample.com/">Go by Example</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/the-way-to-go/">Go入门指南</a> / <a href="https://github.com/Unknwon/the-way-to-go_ZH_CN">Github</a></li>
<li><a href="https://book.douban.com/subject/24869910/">Go 语言程序设计</a></li>
<li><a href="https://www.zhihu.com/question/23486344">怎么学习golang？</a> 里面给出了一些不错的入门资料</li>
<li><a href="https://github.com/golang/go/wiki">Go Wiki</a></li>
</ul>
<h2 id="_2">笔记</h2>
<p>2017-01-01: 目前是官网入门指南 <a href="https://tour.golang.org/list">A Tour of Go</a> 的笔记，大部分代码来至上面。</p>
<h3 id="goroot-gopath">GOROOT 和 GOPATH</h3>
<p>关于 <code>GOROOT</code> 和 <code>GOPATH</code> 环境变量，如果是系统默认安装，而非自定义的安装目录，则 <code>GOROOT</code> 不需要设置。</p>
<blockquote>
<p>GOROOT must be set only when installing to a custom location. <a href="https://golang.org/doc/install#install">from</a></p>
</blockquote>
<p>关于 <code>GOPATH</code>，必须设置，在get/build/install包时用到，第三方的包都会装在这个目录下，包括里面的二进制文件，所以建议将 <code>$GOPATH/bin</code> 加入到 <code>$PATH</code> 环境变量中。更多可以 <code>go help gopath</code>。</p>
<h3 id="package-import">package 和 import</h3>
<p>一个基本的例子:</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>其中package我的理解是继承或者说基于的包名; main包表示这个程序的执行入口，编译时会将这个编译为可执行程序 (<code>go build</code>) 而不是 <code>$GOPATH/pkg/</code> 下的静态库 (<code>go install</code>)。类似Python中的 <code>if __name__ == '__main__'</code>。</p>
<p>import 则表示导入要使用的标准库包或第三方包。</p>
<p>参考:</p>
<ul>
<li><a href="http://thenewstack.io/understanding-golang-packages/">Understanding Golang Packages</a></li>
<li><a href="https://www.golang-book.com/books/intro/11">golang-book Packages</a></li>
</ul>
<p>多个import语句可以使用 <strong>打包导入(factored import)</strong>，更优雅:</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="c1">// 等价</span>
<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>
<span class="kn">import</span> <span class="s">&quot;match&quot;</span>
</pre></div>


<h3 id="exported-names">Exported names</h3>
<p>在 Go 中，首字母大写的名称是 <strong>可被导出</strong> 的。当 import 包时，不被导出的包是无法被访问使用的，所以可以看到如上面的 <code>fmt</code> 包的 <code>Println()</code> 是以大写字母开头。</p>
<h3 id="function">Function</h3>
<div class="hlcode"><pre><span class="kd">func</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span>
<span class="p">}</span>
</pre></div>


<p>函数名后面圆括号里接 <strong>参数</strong>。</p>
<p>参数后面指定 <strong>返回类型</strong>，多个相同的类型 <strong>不能</strong> 省略只写一个; 单个返回值可以不用圆括号括起来; 没有返回值则不写。</p>
<p><strong>Named return values(命名返回值)</strong>，即在函数名后的返回值指定变量名，函数体内配合裸 return 来返回，注意 return 后面不要接返回值了，否则命名返回无效，使用的还是返回的值。另外在这种情况下，返回类型如果相同是可以省略只写一个：</p>
<div class="hlcode"><pre><span class="kd">func</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>


<p>这里不能对参数做命名返回值返回，否则报错:</p>
<div class="hlcode"><pre><span class="c1">// 错误的</span>
<span class="kd">func</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>


<p>函数参数，闭包没啥好写的</p>
<h3 id="variable-constants-and-type">Variable, Constants and Type</h3>
<p>几种定义方式:</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">bool</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span><span class="p">,</span> <span class="mi">100</span>
    <span class="nx">z</span> <span class="o">:=</span> <span class="mi">200</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 输出: false false 1 2 abc 100 200</span>
</pre></div>


<p>Go中声明(declaration)和定义(definition)个人理解是不做区分的(和C不一样)，因为如果声明了变量但是未显式赋值，会隐式赋值给各类型的初始值(zero value，<strong>零值</strong>)。</p>
<p>另外 <code>var var_name var_type</code> 和函数参数一样，变量名在前，类型在后。</p>
<p>另外也可以不指定类型名，Go 会根据赋值判断相应类型</p>
<p>最后，也可以不写 <code>var</code>，改用 <code>:=</code> 的简明赋值语句，但是此语法 <strong>只能用于函数内</strong>，而 <code>var</code> 则可以在函数外使用。</p>
<p>并且在至少有一个新变量，<code>:=</code> 可以用于重声明，比如下面的例子：</p>
<div class="hlcode"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
    <span class="c1">// b 是重声明的，c 是新变量</span>
    <span class="c1">// 如果改为 a, b := 3, 4 则报错：no new variables on left side of :=</span>
    <span class="nx">c</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>声明和导入包一样，可以 <strong>打包声明</strong>:</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">i</span> <span class="kt">bool</span>    <span class="p">=</span> <span class="kc">false</span>
    <span class="nx">j</span> <span class="kt">int</span>     <span class="p">=</span> <span class="mi">1</span>
    <span class="nx">z</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">0.3</span>
<span class="p">)</span>
</pre></div>


<p>关于类型关键词，其中 <code>byte</code> 是 <code>uint8</code> 的别名，<code>rune</code> 是 <code>int32</code> 的别名。</p>
<p>一般情况下，数字用 <code>int</code> 即可。</p>
<p>一些基本类型的零值:</p>
<ul>
<li>数字: 0</li>
<li>布尔: false</li>
<li>字符串: ""</li>
</ul>
<p>Go中类型的转换用 <code>T(v)</code>，将值 v 转换为类型 T:</p>
<div class="hlcode"><pre><span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</pre></div>


<p>Go中类型转换 <strong>必须</strong> 显示指定（C中是可以做隐式转换的）。</p>
<p>常量类型变量声明，使用关键字 <code>const</code>，不能使用 <code>:=</code> 语法</p>
<div class="hlcode"><pre><span class="kd">const</span> <span class="nx">World</span> <span class="p">=</span> <span class="err">&#39;世界&#39;</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="nx">Big</span>   <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">100</span>
    <span class="nx">Small</span> <span class="p">=</span> <span class="nx">Big</span> <span class="o">&gt;&gt;</span> <span class="mi">99</span>
<span class="p">)</span>
</pre></div>


<h3 id="for-if-switch">for / if / switch</h3>
<p><code>for</code>支持几种语法:</p>
<div class="hlcode"><pre><span class="c1">// init statement; condition expression; post statement</span>
<span class="c1">// 另外这里注意只有后自增，没有前自增; 写C/C++时习惯了用前自增，这里总写错</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// init / post statement 可以省略</span>
<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="p">;</span> <span class="nx">sum</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">sum</span>
<span class="p">}</span>

<span class="c1">// 上面的例子，前后两个分号`;`也可以省略，这就是while的语法了</span>
<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="nx">sum</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">sum</span>
<span class="p">}</span>

<span class="c1">// 上面的例子，退出条件也省略，就是无限循环了</span>
<span class="k">for</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>


<p><code>if</code>语法:</p>
<div class="hlcode"><pre><span class="c1">// condition expression</span>
<span class="k">if</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="c1">// if也支持init statement，if初始化的变量作用域只在if主体内</span>
<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="c1">// if ... else if ... else</span>
<span class="k">if</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;&lt;= 3&quot;</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">6</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;&lt;= 6&quot;</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;&gt; 6&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p><code>switch</code>语法:</p>
<div class="hlcode"><pre><span class="c1">// 同样支持初始化语法</span>
<span class="c1">// 和C不同，每个case语句的行为是自动`break`，不需要手动写`break`</span>
<span class="c1">// 如果想保持和C的行为一致，即匹配后还继续往下执行，则可以在case中加上`fallthrough`</span>
<span class="k">switch</span> <span class="nx">os</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span><span class="p">;</span> <span class="nx">os</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s">&quot;darwin&quot;</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;OS X.&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="s">&quot;linux&quot;</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Linux.&quot;</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s.&quot;</span><span class="p">,</span> <span class="nx">os</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 如果switch condition没写，则默认表示 `true`</span>
<span class="c1">// 行为和if ... else if ... else 一样</span>
<span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
<span class="k">switch</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Hour</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">12</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Good morning!&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Hour</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">17</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Good afternoon.&quot;</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Good evening.&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>注:</p>
<ul>
<li>Go中初始、条件等语句不需要用 <code>()</code> 阔起来</li>
<li>主体部分必须用花括号 <code>{}</code> 阔起来</li>
</ul>
<h3 id="defer">defer</h3>
<p><code>defer</code> 语句用于延迟函数的执行直到当前函数 return，但是 defer 的参数会立刻生成。</p>
<p>多个defer语句会进行 <strong>压栈</strong>，最后执行时是 LIFO:</p>
<div class="hlcode"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;begin&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;done&quot;</span><span class="p">)</span>
<span class="c1">// 返回: begin -&gt; end -&gt; 2 -&gt; 1 -&gt; 0</span>
</pre></div>


<h3 id="pointers">Pointers</h3>
<div class="hlcode"><pre><span class="nx">i</span> <span class="o">:=</span> <span class="mi">100</span>
<span class="kd">var</span> <span class="nx">p1</span> <span class="o">*</span><span class="kt">int</span>  <span class="c1">// 如果没有初始化，则零值是`nil`</span>
<span class="nx">p1</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">i</span>
<span class="nx">p2</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">i</span>
<span class="o">*</span><span class="nx">p2</span> <span class="p">=</span> <span class="mi">101</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="o">*</span><span class="nx">p1</span><span class="p">,</span> <span class="o">*</span><span class="nx">p2</span><span class="p">)</span>
</pre></div>


<ul>
<li><code>*T</code> 在声明时表示指向值T的指针</li>
<li><code>&amp;</code> 用于对值 <strong>取址</strong></li>
<li><code>*p</code> 在使用时表示对指针的 <strong>解引用</strong>，即取指针指向的值。</li>
</ul>
<p>这里<code>*</code>需要注意，在不同地方的含义不一样。</p>
<h3 id="struct">Struct</h3>
<p>结构体用法:</p>
<div class="hlcode"><pre><span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span> <span class="kt">int</span>
    <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">v</span> <span class="nx">Vertex</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span> <span class="c1">// 结构体初始化</span>
<span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">6</span>                     <span class="c1">// 通过dot获取结构体字段</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">v</span>    <span class="c1">// 结构体指针</span>
<span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">).</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">7</span> <span class="c1">// 结构体指针获取结构体字段</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span> <span class="c1">// 上面的用法太笨拙，这个更简单</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="c1">// 输出:</span>
<span class="c1">// {6 5}</span>
<span class="c1">// {7 5}</span>
<span class="c1">// {8 5}</span>

<span class="c1">// Struct Literals 结构体字面值</span>
<span class="nx">v1</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="c1">// X: 1, Y: 0</span>
<span class="nx">v2</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{}</span>     <span class="c1">// X: 0, Y: 0</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// has type *Vertex</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
<span class="c1">// 输出: {1 0} {0 0} &amp;{1 2}</span>
<span class="c1">// 注意p的输出结构式带有`&amp;`，表示输出的是结构体指针</span>
</pre></div>


<h3 id="array">Array</h3>
<p>数组是<strong>定长</strong>的 <code>[n]T</code></p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">a1</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span>
<span class="nx">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;hello&quot;</span>
<span class="nx">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;world&quot;</span>
<span class="nx">a2</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a1</span><span class="p">,</span> <span class="nx">a2</span><span class="p">)</span>
<span class="c1">// 输出: [hello world] [1 2 3]</span>
</pre></div>


<p>注意长度 <code>[n]</code> 也是类型的一部分</p>
<h3 id="slice">Slice</h3>
<p>数组是定长的，Go还提供了切片这个数据结构，长度是<strong>动态变化</strong>的，所以这个用的比数组更频繁。</p>
<p>（刚看到 slice/切片 这个词，第一反应是一个函数，结果是一个数据结构...）</p>
<p>因为长度是动态变化，所以声明是 <code>[]T</code>，括号中不写。</p>
<p>Go中做切片（这里是动词）操作，返回的是切片。</p>
<div class="hlcode"><pre><span class="nx">array</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">slice1</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="nx">slice2</span> <span class="o">:=</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice1</span><span class="p">,</span> <span class="nx">slice2</span><span class="p">)</span>
<span class="c1">// import &quot;reflect&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">slice1</span><span class="p">),</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">slice2</span><span class="p">))</span>
<span class="c1">// 输出:</span>
<span class="c1">// [2 3] [1]</span>
<span class="c1">// []int []int</span>
</pre></div>


<p><strong>切片自身并不存储数据，它是对底层数组的引用</strong>。</p>
<p>所以对切片中数据的修改，会影响相应的底层数组的值，也会影响其它引用到这个数组的切片</p>
<div class="hlcode"><pre><span class="c1">// 接上面的例子</span>
<span class="n">slice1</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">100</span>
<span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">slice1</span><span class="p">,</span> <span class="n">slice2</span><span class="p">)</span>
<span class="c1">// 输出: [1 100 3] [100 3] [1 100]</span>
</pre></div>


<p>切片字面值（slice literal）和数组字面值（array literal）一样，只是不需要指定长度:</p>
<div class="hlcode"><pre><span class="nx">slice1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">slice2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="kt">int</span>
    <span class="nx">b</span> <span class="kt">bool</span>
<span class="p">}{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="kc">false</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>  <span class="c1">// 注意最后的逗号不能省略</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice1</span><span class="p">,</span> <span class="nx">slice2</span><span class="p">)</span>
<span class="c1">// 输出: [1 2 3] [{1 true} {2 false} {3 true}]</span>
</pre></div>


<p>上面注意最后的逗号不能省略，否则报错：</p>
<blockquote>
<p>missing ',' before newline in composite literal</p>
</blockquote>
<p>原因参考 <a href="https://stackoverflow.com/a/29301344/1276501">这个回答</a>：</p>
<blockquote>
<p>a semicolon is automatically inserted into the token stream at the end of a non-blank line if the line's final token is<br />
- ...<br />
- one of the operators and delimiters ++, --, ), ], or }</p>
</blockquote>
<p>切片的使用和 Python 类似，支持:</p>
<div class="hlcode"><pre><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="nx">s</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
<span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span>
<span class="nx">s</span><span class="p">[:]</span>
</pre></div>


<p>切片有 length 和 capacity 的概念</p>
<ul>
<li><code>length</code> 通过 <code>len(s)</code> 获取，表示切片中元素的个数</li>
<li><code>capacity</code> 通过 <code>cap(s)</code> 获取，表示切片引用的 <strong>底层数组</strong> 中元素的个数，从切片的第一个元素开始计算</li>
</ul>
<p>下面这个例子比较有意思，感觉容易入坑:</p>
<div class="hlcode"><pre><span class="kd">func</span> <span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;len=%d cap=%d %v\n&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">// 注意这里还可以扩展，因为是引用，底层数组一直存在</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="c1">// 这里capacity就减少了</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 输出</span>
<span class="c1">// len=5 cap=5 [1 2 3 4 5]</span>
<span class="c1">// len=0 cap=5 []</span>
<span class="c1">// len=4 cap=5 [1 2 3 4]</span>
<span class="c1">// len=3 cap=3 [3 4 5]</span>
</pre></div>


<p>切片的零值是 <code>nil</code>:</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>  <span class="c1">// 注意和s := []int{}不一样，这个是空切片，赋值过的</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;slice is nil&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p><code>make</code> 函数可以用来创建切片，并指定 length（必选）和 capacity（可选）:</p>
<div class="hlcode"><pre><span class="nx">s1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">printSlice</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span>

<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nx">printSlice</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span>
<span class="c1">// 输出</span>
<span class="c1">// len=3 cap=3 [0 0 0]</span>
<span class="c1">// len=3 cap=5 [0 0 0]</span>
</pre></div>


<p>二维切片(类似C中二维数组):</p>
<div class="hlcode"><pre><span class="c1">// len(s) = 2, cap(s) = 2</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">{</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">},</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">},</span>
<span class="p">}</span>
</pre></div>


<p>Go对切片的 append 操作提供了内置函数<code>append(s []T, v1, v2, v3, ...T) []T</code>，最后返回append后的切片; 因为切片大小是动态的，所以如果capacity不够，会自动扩容:</p>
<div class="hlcode"><pre><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="c1">// 输出:</span>
<span class="c1">// len=1 cap=3 [0]</span>
<span class="c1">// len=2 cap=3 [0 1]</span>
<span class="c1">// len=4 cap=6 [0 1 2 3]</span>
</pre></div>


<p>for循环切片:</p>
<div class="hlcode"><pre><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="c1">// i 是切片索引，v是值的一个copy</span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// i 是切片索引</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="p">}</span>
</pre></div>


<p>和Python一样，如果不关心索引，可以直接赋值给变量名<code>_</code></p>
<p>关于 range 的扩展阅读：</p>
<ul>
<li><a href="https://xiaozhou.net/something-about-range-of-go-2016-04-10.html">聊聊Go中的Range关键字</a></li>
<li><a href="https://qianlonggit.gitbooks.io/the-golang-standard-library-by-example/content/chapter02/02.5.html">unicode — Unicode码点、UTF-8/16编码</a></li>
<li><a href="https://github.com/golang/go/wiki/Range">go wiki - Range</a></li>
<li><a href="https://gobyexample.com/range">Go by Example: Range</a></li>
</ul>
<h3 id="maps">Maps</h3>
<p>映射（也就是字典吧）表示一个 key/value 对集合，声明语法:</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">map_name</span> <span class="kd">map</span><span class="p">[</span><span class="nx">map_key_type</span><span class="p">]</span><span class="nx">map_value_type</span>
</pre></div>


<p><code>map_value_type</code> 表示 map 值的类型，类似于 slice 的 <code>[]int</code> 这种表示 slice 中的值是 int。</p>
<p>即:</p>
<div class="hlcode"><pre><span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span> <span class="kt">int</span>
    <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Vertex</span>  <span class="c1">// 声明</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Vertex</span><span class="p">)</span>  <span class="c1">// 创建</span>
    <span class="nx">m</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
    <span class="nx">m</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 输出: map[a:{3 4} b:{1 2}]</span>
</pre></div>


<p>只声明的map，零值是nil，nil map不能添加key/values，即没有下面的make则后面不能操作。</p>
<p>声明、创建这块也可以直接写为<code>m := map[string]Vertex</code></p>
<p>映射字面值(map literal):</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Vertex</span><span class="p">{</span>
    <span class="s">&quot;a&quot;</span><span class="p">:</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s">&quot;b&quot;</span><span class="p">:</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>  <span class="c1">// 注意逗号</span>
<span class="p">}</span>

<span class="c1">// If the top-level type is just a type name, you can omit it from the elements of the literal.</span>
<span class="c1">// 按我理解是表示 map 已经定义了值的类型，所以在里面的字面值不需要再定义</span>
<span class="c1">// 下面是简写，省去内部的值类型</span>
<span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Vertex</span><span class="p">{</span>
    <span class="s">&quot;a&quot;</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s">&quot;b&quot;</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
<span class="p">}</span>
</pre></div>


<p>map的几个操作:</p>
<div class="hlcode"><pre><span class="c1">// 修改某个key的value</span>
<span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>

<span class="c1">// 获取某个key的value</span>
<span class="nx">v</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>

<span class="c1">// 删除某个key</span>
<span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>

<span class="c1">// 测试某个key是否在m中</span>
<span class="c1">// ok是boolean，存在则为true，否则是false</span>
<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
</pre></div>


<h3 id="methods">Methods</h3>
<p>Go没有类，但是可以给自定义类型（如结构体）定义方法（methods）。</p>
<p>method 和 function 类似，只不过多了一个特殊的接收者参数（receiver），位置在 func 关键字和 method name 之间。</p>
<div class="hlcode"><pre><span class="c1">// 如这里定义Abs这个方法，属于Vertex这个结构体，`(v Vertex)`就是function没有的多出的部分</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Vertex</span><span class="p">)</span> <span class="nx">AbsMethod</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 调用</span>
<span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">AbsMethod</span><span class="p">())</span>

<span class="c1">// 这个是function, 将Vertex结构体当普通参数</span>
<span class="kd">func</span> <span class="nx">AbsFunc</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Vertex</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 调用</span>
<span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">AbsFunc</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
</pre></div>


<p>如上所说，不光结构体可以声明方法，比如自定义类型:</p>
<div class="hlcode"><pre><span class="kd">type</span> <span class="nx">MyFloat</span> <span class="kt">float64</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">MyFloat</span><span class="p">)</span> <span class="nx">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">f</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="o">-</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>但是 <strong>receiver的类型必须定义在当前包里，不能给其它包里定义的类型声明method，比如内置类型</strong>。</p>
<p>上面使用的 receiver 是一个值（value receiver），receiver还可以是一个指针（pointer receiver），如:</p>
<div class="hlcode"><pre><span class="c1">// method</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nx">ScaleMethod</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">*</span> <span class="nx">f</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*</span> <span class="nx">f</span>
<span class="p">}</span>

<span class="c1">// function</span>
<span class="kd">func</span> <span class="nx">ScaleFunc</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">,</span> <span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">*</span> <span class="nx">f</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*</span> <span class="nx">f</span>
<span class="p">}</span>
</pre></div>


<p>因为Go里函数参数是传值，相当于一份拷贝，所以如果使用 <code>func (v Vertex) Scale...</code> 而不是 <code>func (v *Vertex) Scale...</code> ，则实际 v.X 和 v.Y 的值并没有被改变。</p>
<p>关于这块调用 Scale 时针对 pointer 和 value，需要注意一个坑:</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">v</span> <span class="nx">Vertex</span>

<span class="c1">// 针对上面的Scale</span>
<span class="nx">ScaleFunc</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1">// compile error!</span>
<span class="nx">ScaleFunc</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1">// ok</span>
<span class="nx">v</span><span class="p">.</span><span class="nx">ScaleMethod</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>     <span class="c1">// ok, as (&amp;v).ScaleMethod()</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">v</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">ScaleMethod</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>     <span class="c1">// ok</span>

<span class="c1">// 针对上上面的Abs</span>
<span class="nx">AbsFunc</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>           <span class="c1">// ok</span>
<span class="nx">AbsFunc</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>          <span class="c1">// compile error!</span>
<span class="nx">v</span><span class="p">.</span><span class="nx">AbsMethod</span><span class="p">()</span>        <span class="c1">// ok</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">v</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">AbsMethod</span><span class="p">()</span>         <span class="c1">// ok, as (*p).AbsMethod()</span>
</pre></div>


<p>为了方便，Go的解释器对 method 作了一些自动化处理，如上例子，不论是 pointer receiver 还是 value receiver 的方法，都可以通过 pointer 或 value 来调用。</p>
<p>更倾向于选择使用 pointer receiver 的原因有两个:</p>
<ol>
<li>method 内部可以修改 receiver 的值</li>
<li>不是按值传递，所以更节省空间，比如需要传递的是一个很大的结构体</li>
</ol>
<h3 id="interfaces">Interfaces</h3>
<p>Go Tour上这块英文感觉有点绕，需要多读几遍。</p>
<blockquote>
<p>An interface type is defined as a set of method signatures.</p>
</blockquote>
<p>一个接口类型是一组 method 的定义的集合。</p>
<blockquote>
<p>A value of interface type can hold any value that implements those methods.</p>
</blockquote>
<p>接口类型是一个抽象类型，它的值可以是任何值，只需要这个值实现了接口的 methods</p>
<p>接口的好处就是将接口的定义和实现分离。</p>
<div class="hlcode"><pre><span class="c1">// 接口类型</span>
<span class="kd">type</span> <span class="nx">I</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">M</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 具体类型</span>
<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">S</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nx">M</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">S</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 具体类型</span>
<span class="kd">type</span> <span class="nx">F</span> <span class="kt">float64</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">F</span><span class="p">)</span> <span class="nx">M</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span> <span class="nx">I</span>

    <span class="nx">i</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span><span class="s">&quot;Hello&quot;</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;(%v, %T)\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">i</span><span class="p">.</span><span class="nx">M</span><span class="p">()</span>

    <span class="nx">i</span> <span class="p">=</span> <span class="nx">F</span><span class="p">(</span><span class="mf">0.11</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;(%v, %T)\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">i</span><span class="p">.</span><span class="nx">M</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// 输出</span>
<span class="c1">// (&amp;{Hello}, *main.T)</span>
<span class="c1">// Hello</span>
<span class="c1">// (0.11, main.F)</span>
<span class="c1">// 0.11</span>
</pre></div>


<p><strong>一个接口需要挂载到一个底层具体类型上，调用接口的方法实际就是调用底层具体类型的同名方法.</strong></p>
<p>如果实际类型是 nil (nil underlying value)，则接口也是 nil</p>
<p>但如果接口类型是 nil (nil interface value)，则无法调用它的 method，否则报错</p>
<p>空接口定义: <code>var i interface{}</code>，接口i可以是任何值。</p>
<p>类型断言（type assertion）让接口值可以访问所挂载具体类型的值: <code>t := i.(T)</code>，其中i是接口值，T是具体类型名：</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">i</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="s">&quot;hello&quot;</span>

<span class="nx">s</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

<span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>

<span class="c1">// 这个和之前的map test类似</span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">float64</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>

<span class="nx">f</span> <span class="p">=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">float64</span><span class="p">)</span> <span class="c1">// panic</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</pre></div>


<p>type switch 结合了接口类型和switch语句，语法<code>i.(type)</code>，和type assertion语法有点像。</p>
<div class="hlcode"><pre><span class="c1">// i is interface</span>
<span class="k">switch</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Twice %v is %v\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%q is %v bytes long\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;I don&#39;t know about type %T!\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>fmt包中定义了Stringer接口，方法String()，如目前用到最多的fmt.Println()就根据类型的String()方法输出内容:</p>
<div class="hlcode"><pre><span class="c1">// type Stringer interface {</span>
<span class="c1">//     String() string</span>
<span class="c1">// }</span>
<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span> <span class="kt">string</span>
    <span class="nx">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%v (%v years)&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Age</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="s">&quot;Arthur Dent&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</pre></div>


<h3 id="goroutine">goroutine</h3>
<p>轻量级线程(lightweight thread)</p>
<p>goroutines在同一个地址空间中运行，所以访问共享内存必须进行同步</p>
<p>使用关键字<code>go</code>，<code>go func(x, y)</code>中x, y是在当前goroutine中定义，但是func的执行是在一个新的goroutine:</p>
<div class="hlcode"><pre><span class="kd">func</span> <span class="nx">say</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">say</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">)</span>
    <span class="nx">say</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>如果当前goroutine结束，则新起的goroutine也会结束。所以这个和执行时间、顺序有关系，上面的例子会出现偶尔world只输出4次的情况。如果去掉time.Sleep，则可能会出现world还没来得及输出就已经结束了。</p>
<h3 id="channel">channel</h3>
<p>channel是一个有类型的管道(typed conduit)，可以用来接收或发送数据，操作符<code>&lt;-</code>，channel 和 <code>&lt;-</code>的方向表示了数据流的方向:</p>
<div class="hlcode"><pre><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">v</span>    <span class="c1">// 发送v到channel ch</span>
<span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>  <span class="c1">// 接收来自channel ch的数据，并赋值给v</span>
</pre></div>


<p>和slice，map类似，channel 在使用前需要创建:</p>
<div class="hlcode"><pre><span class="n">ch</span> <span class="o">:=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="kt">int</span><span class="p">)</span>
</pre></div>


<p><strong>默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步。</strong></p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">sum</span> <span class="c1">// send sum to c</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>

    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="nx">c</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">:],</span> <span class="nx">c</span><span class="p">)</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">c</span> <span class="c1">// receive from c</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>上面例子是goroutine和channel的配合。</p>
<p>创建channel时，第二个参数可以指定channel大小，使其为<strong>buffered channel</strong>:</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>如果是buffered channel，则如果buffer满了，则发送给channel会被block; 如果buffer空了，则从channel读取数据会被block。</p>
<p>上面例子如果在&lt;-ch之前再写数据进ch，会导致报错: fatal error: all goroutines are asleep - deadlock!</p>
<p>在读取channel时，如果指定第二个参数，可以确认channel是否关闭。对channel进行for循环可以持续从channel读取数据，直到channel关闭。</p>
<div class="hlcode"><pre><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>    <span class="c1">// 关闭channel</span>
<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>  <span class="c1">// 检查channel是否关闭</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>  <span class="c1">// 持续从channel读取数据</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>


<p><code>select</code> 语句用于从多个channel中选出一个可用的channel来执行，都没有则block，如果有多个则随机选一个; 如果有<code>default</code> case，则不会block，没有任何case可执行时则用default case</p>
<div class="hlcode"><pre><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c1</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c2</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">default</span><span class="p">:</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
  
</div>
    </div>
    <div id="footer">
      <div class="footer-left">
        <p>
        Copyright © 2012-2020 wangyaoxu.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        Theme by <a href="https://github.com/tankywoo/yasimple_x2" target="_blank">YASimple_X2</a>.
        </p>
        <p>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
      </div> <!-- end footer-left -->
      <div class="footer-right">
        <p>站点最后生成 2020-09-26 02:43:53</p>
        <p><a href="https://github.com/tankywoo/wiki.tankywoo.com">Fork me on Github</a></p>
        <p><a href="http://www.miitbeian.gov.cn/">京ICP备16016622号</a></p>
      </div> <!-- end footer-right -->
    </div>

    
    

    <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F754de327571c0ba7ff50a61fc964e196' type='text/javascript'%3E%3C/script%3E"));
    </script>
  </body>
</html>